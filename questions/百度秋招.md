# 一面
## 虚函数

虚函数是在基类中声明的，而在派生类中进行重写（override）的函数。通过使用 virtual 关键字声明一个函数为虚函数，它使得在运行时能够动态地确定调用的是哪个版本的函数。

虚函数的作用：
- 实现多态性（Polymorphism）：允许通过基类指针或引用调用派生类对象的函数，根据实际对象的类型选择相应的函数实现。
- 运行时绑定（Runtime Binding）：虚函数通过表格（虚函数表）的方式实现，使得在运行时动态地绑定函数调用。

虚函数表：每个含有虚函数的类都有一个虚函数表，其中存储了虚函数的地址。对象的内存布局中包含一个指向虚函数表的指针。派生类的虚函数表包含基类的虚函数表，并在适当的位置添加或替换新的虚函数地址。

纯虚函数：**是一个在基类中声明但没有提供实现的虚函数**，它通过在声明中使用 = 0 来标识。类含有纯虚函数的类被称为抽象类，不能被实例化。派生类必须实现纯虚函数，否则也会变为抽象类。

虚析构函数：基类的析构函数是虚函数，当通过基类指针删除派生类对象时，会调用派生类的析构函数。这是为了确保正确的对象销毁。

## 内存池

内存池的目的/优势：
- 减少内存碎片：预先分配一块连续的内存，避免了频繁的小块内存分配和释放，减少了内存碎片的产生。
- 提高内存分配效率：内存池可以通过一次分配多次使用，减少了内存分配的开销。

内存池的实现方式：
- 固定大小的块：内存池通常将内存划分成大小相等的块，每个块都可以独立地分配给应用程序。
- 预分配内存：内存池在初始化时会预分配一定大小的内存块，并将这些块组织成链表或其他数据结构。
- 分配策略：内存池可以采用不同的分配策略，例如首次适应、最佳适应、最差适应等。
- 

使用场景：
- 频繁地小块内存分配：如网络编程、嵌入式系统等。
- 实时系统：在实时系统中，内存分配的延迟是一个重要的考量因素。

内存池的实现步骤：
- 预分配内存块：在初始化时，内存池预分配一块固定大小的内存。
- 组织内存块：将预分配的内存划分成大小相等的块，并组织成链表或其他数据结构。
- 分配内存：当应用程序需要内存时，从内存池中分配一个块。
- 释放内存：当应用程序不再需要内存时，将内存块释放回内存池。

## C++11新特性

自动类型推导（Auto）：允许编译器推导变量的类型，使代码更加简洁。

    auto x = 5; // x的类型将被推导为int

范围-based for 循环：简化了对容器元素的遍历。


    std::vector<int> numbers = {1, 2, 3, 4, 5};
    for (const auto& num : numbers) {
        // 使用num
    }

智能指针：引入了std::shared_ptr和std::unique_ptr等智能指针，用于管理动态分配的内存，帮助防止内存泄漏。

Lambda 表达式：允许在函数内部定义匿名函数，提高代码可读性和灵活性。

    auto add = [](int a, int b) { return a + b; };

nullptr：引入了空指针常量nullptr，用于替代传统的空指针NULL。

强制类型转换（Type Casting）：引入了static_cast、dynamic_cast、const_cast、reinterpret_cast等更安全和灵活的类型转换操作符。

右值引用和移动语义：支持通过右值引用实现移动语义，提高了对临时对象的处理效率。

## 什么时候用auto？
类型较长或复杂：当变量的类型较长或复杂时，使用 auto 可以简化代码并提高可读性。

    std::map<std::string, std::vector<int>> myMap;
    // 使用auto简化迭代器的声明
    for (auto it = myMap.begin(); it != myMap.end(); ++it) {
        // ...
    }

模板编程：在模板编程中，使用 auto 可以避免重复书写类型，使代码更通用。

    template <typename T, typename U>
    auto add(T x, U y) -> decltype(x + y) {
        return x + y;
    }
迭代器和范围-based for 循环：在使用迭代器和范围-based for 循环时， auto 可以简化类型声明。

    std::vector<int> numbers = {1, 2, 3, 4, 5};
    // 使用auto声明迭代器
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        // ...
    }
    // 使用范围-based for 循环
    for (const auto& num : numbers) {
        // ...
    }

方便迭代器类型：当使用模板或容器类型时， auto 可以方便地获取迭代器的类型，而无需显式指定。


    std::vector<int> numbers = {1, 2, 3, 4, 5};
    auto it = numbers.begin(); // it的类型是std::vector<int>::iterator

## 智能指针

std::shared_ptr：共享指针。多个 std::shared_ptr 可以共享同一个对象，并且会跟踪对象的引用计数。当引用计数变为零时，对象会被删除。

std::unique_ptr：独占指针。一个 std::unique_ptr 拥有对其指向的对象的唯一所有权。当 std::unique_ptr 被销毁时，它指向的对象也会被销毁。

std::weak_ptr：弱引用指针。std::weak_ptr 是为了解决 std::shared_ptr 的循环引用问题而引入的。std::weak_ptr 既不增加引用计数，也不影响对象的生命周期。

## std::map和std::unordered_map?

std::map：是一个有序的关联容器，它使用红黑树实现。这意味着 std::map 中的元素是按键的升序顺序进行排序的。插入、查找和删除操作的时间复杂度是 O(log n)。

std::unordered_map：是一个无序的关联容器，它使用哈希表实现。这意味着 std::unordered_map 中的元素没有特定的顺序。插入、查找和删除操作的平均时间复杂度是 O(1)。但需要注意，对于某些特殊情况，最坏情况下的时间复杂度可能为 O(n)。

## 一个系统进程大概多大?

Linux系统进程的大小会受到多种因素的影响，包括进程的功能、所加载的库和模块、进程的数据结构、系统架构等。通常情况下，一个典型的用户空间进程的大小可以在几十 KB 到几百 MB 之间。

在 Linux 中，可以使用 pmap 命令查看进程的内存映射，包括各个段的大小。

    pmap <pid>

可以看到进程的内存布局和各个段的大小。

需要注意的是，这里提到的大小是虚拟内存的大小，而不是物理内存。实际占用的物理内存可能会更少，因为虚拟内存中的一部分可以尚未实际分配物理内存。

## 最大socket数量？

在一个系统中，能够同时打开的文件描述符（包括网络套接字）的数量是有限的。这个限制通常由系统的资源限制、文件描述符表的大小等因素决定。

    ulimit -n

这个命令会显示当前用户对于文件描述符数量的限制。如果你需要修改这个限制，可以使用 ulimit 命令，但是需要注意的是这只是对当前 shell 会话有效，而不是全局设置。

# 二面

## C++中的运算符，单目运算符，三元运算符，所有运算符中哪些不可以重载?

- 算术运算符：+、-、*、/、%、++、--
- 关系运算符：==、!=、<、>、<=、>=
- 逻辑运算符：&&、||、!
- 位运算符：&、|、^、~、<<、>>
- 赋值运算符：=、+=、-=、*=、/=、%=、&=、|=、^=、<<=、>>=
- 条件运算符（三元运算符）：? :
- 成员访问运算符：.、->
- 指针运算符：、&、->
- 逗号运算符：,
- sizeof 运算符
- typeid 运算符
- new 和 delete 运算符
- 强制类型转换运算符：dynamic_cast、static_cast、const_cast、reinterpret_cast

不可以被重载的：

- 点运算符(.)
- 成员访问运算符(->)
- 条件运算符(?:)
- sizeof 运算符
- typeid 运算符
- new 和 delete 运算符

> 浅谈:
> "operator new"和"new operator"
>
> operator new：这是C++中的一个函数，它用于在堆上动态分配内存。它接受一个参数，即要分配的字节数，并返回一个指向分配内存的指针。
>
> int* ptr = static_cast<int*>(operator new(sizeof(int)));
>
> new operator：这是C++中的一个关键字，用于创建对象并调用构造函数。它首先调用operator new来分配内存，然后调用类的构造函数来初始化对象。例如，下面的代码使用new operator创建了一个int类型的对象：
>
> int* ptr = new int(10);
