# 如何防止一个头文件 include 多次

使用预处理指令#ifndef、#define和#endif来创建一个头文件保护

```cpp
#ifndef MYHEADER_H  
#define MYHEADER_H  
  
// 头文件的内容  
// ...  
  
#endif // MYHEADER_H
```

或使用#pragma once，预处理器将记录包含此指令的文件，并确保在单次编译过程中不会多次包含该文件。

具体来说，当预处理器遇到#pragma once时，它通常会做以下几件事：
- 预处理器将在内部维护一个列表，记录已经处理过的头文件。每当遇到#pragma once，预处理器都会检查这个列表。
- 如果头文件已经在列表中，预处理器就会跳过这个头文件，不再处理它。这就防止了同一个头文件在单次编译中被重复包含。
- 如果头文件还不在列表中，预处理器就会将其添加到列表中，然后正常处理这个头文件。


# #pragma once和#ifndef区别

#ifndef：依赖于自定义的宏名，可以保证同一份文件或内容相同的不同文件不会被包含两次。

是C/C++语言的标准支持，兼容性好。可以针对一个文件中的部分代码。如果自定义的宏名重名，可能导致编译器找不到声明的情况。编译器每次都需要打开头文件才能判定是否有重复定义，可能使得编译大型项目时的时间较长。

#pragma once：由编译器提供保证，同一个文件不会被包含多次。不会出现宏名碰撞引发的问题。可以提高大型项目的编译速度。

但其是非标准的，有些编译器不支持。如果某个头文件有多份拷贝，不能保证它们不被重复包含。

# 静态库和动态库的区别


静态库:在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库， 因此体积较大 。

动态库:在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在， 因此代码体积较小。

动态库的好处:不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例。

# 动态链接和静态链接的区别

在静态链接中，编译器将程序所需的库文件的代码和数据复制到可执行文件中。可执行文件包含了程序所需的所有代码和数据，因此它可以独立运行，不需要依赖外部的库文件。

静态链接的缺点是，可执行文件的体积较大，并且如果多个可执行文件使用相同的库，每个可执行文件都会包含一份该库的拷贝。

在动态链接中，可执行文件只包含了程序的代码和数据，而所需的库文件在程序运行时由操作系统动态加载。当程序启动时，操作系统会根据需要查找并加载程序所需的库文件，将它们映射到进程的地址空间中。

动态链接的优点是，可执行文件的体积较小，并且多个可执行文件可以共享同一份库文件的拷贝，减少了资源占用。另外，如果库文件更新或修复了bug，只需要替换库文件而无需重新编译程序。

#  gcc编译的过程

预处理（Preprocessing）：预处理器处理C语言源代码，扫描程序中所有的#开头的预编译指令，并将它们替换成相应的文本。预编译指令可以包括头文件包含、条件编译等等。预处理器会删除源代码中的注释，处理以#开头的命令，如头文件的展开、宏定义的替换等。

编译（Compilation）：编译器将预处理后的代码转换成汇编代码。在这个过程中，编译器会对代码进行词法分析和语法分析，生成相应的中间代码。中间代码是一种与特定机器无关的代码表示形式，它将源代码转化为了一种抽象的表示形式，方便后续的优化和转换。

汇编（Assembly）：汇编器将编译得到的汇编代码转换成机器码。这个过程会将汇编代码转换为可执行代码，同时还会生成调试信息和符号表。

链接（Linking）：链接器将目标代码与其他代码片段进行合并，生成最终的可执行程序。在这个过程中，链接器会处理函数库。函数库一般分为静态库和动态库两种，链接器会在系统默认的搜索路径下进行查找，链接到相应的库函数，实现函数调用。

通过这四个步骤，GCC将源代码转换成了可执行程序。使用“-E”选项查看预处理结果，使用“-S”选项查看编译结果。

# C++的符号表

符号表是编译过程中生成的一种数据结构，用于存储关于源代码中标识符（如变量名、函数名、类名等）的信息。符号表使得编译器能够跟踪每个标识符的定义和使用情况，以及它们的属性，如类型、作用域、存储类别等。

- 名字解析和类型检查：编译器使用符号表来确定标识符的类型，以便进行类型检查和解析重载函数或运算符。
- 作用域管理：符号表帮助编译器管理不同作用域（如全局作用域、局部作用域、类作用域等）中的标识符，确保标识符的可见性和生命周期正确无误。
- 代码生成：在代码生成阶段，编译器使用符号表中的信息来确定变量的存储位置、生成函数调用的代码等。
- 链接：在链接阶段，符号表中的信息用于解析程序各部分之间的引用，如函数调用或全局变量的引用。

# C++的单元测试

单元测试是软件开发过程中的一个重要环节，它帮助开发者确保代码片段（如函数、类、模块）按照预期工作，同时也便于在后期维护中识别和修复引入的错误。

Boost.Test是Boost库的一部分，提供了丰富的工具来编写和运行C++测试用例。它支持静态和动态库的形式，灵活性高。

# debug断点方法

下断点式debug：在可能出现问题的位置插入exception或print argument，观察程序在该位置的行为。这种方式简单易用，但无法展示循环内部的情况，对大型程序的逻辑性问题甄别效果有限。

异常断点debug：针对可能出现空指针的问题设置断点，当空指针发生时停止程序，便于排查小概率事件的bug。

条件断点debug：在循环中设置条件断点，可以在满足特定条件时停止程序，便于分析循环内部的问题。

# 怎么查看内存泄漏

Valgrind：用于内存泄漏检测、内存调试和性能分析。对于Linux系统，Valgrind中的Memcheck工具特别有用于检测内存泄漏和未定义的内存使用。

Visual Studio：它提供了内置的诊断工具来检测内存泄漏。

AddressSanitizer：ASan是一个快速的内存错误检测器，可以检测包括内存泄漏在内的多种内存错误。GCC和Clang都支持使用AddressSanitizer，只需要在编译时添加相应的参数：

对于GCC和Clang：

```cpp
-fsanitize=address -fno-omit-frame-pointer -g
```

# 分析C++的core文件

使用GDB分析core文件，需要拥有引起崩溃的程序的可执行文件，并确保它包含调试信息（通常是在编译时使用-g选项）。

首先查看导致崩溃的函数调用堆栈（bt命令）。从最顶层的堆栈帧开始检查，这些帧显示了程序崩溃的直接原因。深入查看每一帧的局部变量和参数，理解为什么会发生崩溃。

查看变量值和内存状态：使用 print 或者 x 命令可以查看变量值和内存状态。例如，使用 print 可以查看某个变量的值；而使用 x 可以查看指定地址处的内存内容。

使用 info registers 命令查看寄存器状态：这个命令可以列出所有寄存器及其当前值。可以使用它来分析程序崩溃时寄存器状态是否正常。


# GDB有哪些命令

运行程序：
- run：启动程序并运行到主函数或断点处。
- start：启动程序并暂停在主函数的第一行。
- continue：继续执行程序，直到下一个断点或程序结束。

设置断点：
- break <function>：在函数入口处设置断点。
- break <line>：在指定行设置断点。
- break <file>:<line>：在指定文件的指定行设置断点。
- break if <condition>：在满足条件时设置断点。

查看源代码：
- list：显示当前执行位置附近的源代码。
- list <function>：显示指定函数的源代码。

查看变量：
- print <variable>：打印变量的值。
- display <variable>：持续打印变量的值，每次停止时都会显示。
- info locals：显示当前函数的局部变量。
- info args：显示当前函数的参数。

调试执行控制：
- step：单步执行，进入函数调用。
- next：单步执行，跳过函数调用。
- finish：执行完当前函数并停止在调用者处。

堆栈和帧：
- backtrace：显示当前的函数调用堆栈。
- frame <num>：切换到指定帧（函数调用）。

# gcc和g++的区别



两者在处理不同后缀的文件时，表现也不同。对于后缀为.c的文件，gcc将其视为C程序，而g++则将其视为C++程序。然而，对于后缀为.cpp的文件，两者都会将其视为C++程序。

再者，在编译阶段，g++会调用gcc。虽然两者在编译C++代码时是等价的，但由于gcc命令不能自动和C++程序使用的库链接，因此通常使用g++来完成链接过程。

此外，虽然两者都执行预处理、编译、汇编和链接四个步骤来生成可执行程序，但在一些细节上有所不同。例如，g++在编译时会自动处理C++的特定语法和特性，而gcc则更专注于C语言的编译器。

# 怎么提升编译速度

梳理编译单元：每一个cpp文件将会生成对应的一个.o目标单元，将小的编译单元合并成大的编译单元对编译速度会有显著的提升。应该将修改频率低的文件进行编译单元合并，如果将高修改频率的cpp文件放入合并后的编译单元，那么每次修改这个文件都会导致包含这个大编译单元重新编译。另外，合并的编译单元尽可能地有一定关联度，可以按照业务功能来划分。

使用预编译头：编译器会在编译项目的第一次过程中解析和编译一组指定的头文件，然后将其保存为二进制文件（通常是.pch文件）。在后续的编译过程中，编译器会在开始编译之前先加载这个预编译头文件，从而跳过对这些头文件的解析和编译，直接使用已经编译好的结果，提高编译速度。

例如：当a,cpp b.cpp c.cpp都包含temp.h头文件时，在编译的时候，temp.h会被解析三遍，分别与a，b，c结合生成.o文件。这样我们可以预先对头文件进行编译，生成temp.h.gch文件，这样只需要解析一次temp.h，原来的a.cpp,b.cpp,c.cpp文件仍然include temp.h就好了，只是需要最先包含temp.h。


# core dump如何排查？

Coredump叫做核心转储，它是进程运行时在突然崩溃的那一刻的一个内存快照。

使用gdb来分析， bt命令来查看程序崩溃时的堆栈信息。使用 print 命令来查看变量的值。使用 info registers 命令可以查看程序崩溃时寄存器的状态。使用x命令查看内存地址的内容

例如： x/4xb &test  查看变量 test 所在地址开始的连续4个字节的内容，并以十六进制形式显示。

# 查看进程的堆栈

使用 ps 命令或其他方法找到目标进程的PID（进程ID）。gdb <可执行文件名> <PID>，进入GDB后，可以使用以下命令来查看堆栈：
- bt：显示当前堆栈的回溯信息，即显示函数调用链。
- info stack：显示当前堆栈的详细信息，包括堆栈顶部和底部的地址。
- backtrace full：显示详细的回溯信息，包括局部变量的值。

# 进程有哪些状态，出现每种状态之后怎么去分析和排查？
- 创建状态：进程刚刚被创建，但尚未被操作系统调度执行。
- 就绪状态：进程已经准备好运行，等待系统分配处理器资源。
- 运行状态：进程正在执行指令，占用处理器资源。
- 阻塞状态：进程在执行期间发生了某些事件（如等待I/O操作、等待信号量等），导致无法继续执行，暂时释放处理器资源。
- 终止状态：进程已经执行完毕，或者由于某种原因被终止。

对于进程处于每种状态的排查和分析，可以采取以下方法：

若进程长时间处于就绪状态，而没有被调度执行，可能是因为系统资源不足导致调度延迟。可以通过检查系统的资源利用情况和调度算法来排查问题。

如果某个进程长时间占用处理器资源，导致其他进程无法得到执行，可能是因为该进程的代码存在死循环或者长时间的计算操作。需要检查该进程的代码逻辑。

当进程在等待某些事件（如I/O操作）而被阻塞时，可以通过检查进程的阻塞原因来分析问题。可能是由于设备故障、资源竞争或者死锁等原因导致的阻塞。

如果进程意外终止，可能是由于程序错误、异常情况或者系统故障导致的。可以通过查看系统日志、调试程序代码定位问题。



