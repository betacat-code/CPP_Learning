# 智能指针
## 实现原理
智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。

常见的智能指针类型包括std::unique_ptr、std::shared_ptr和std::weak_ptr，它们分别提供了不同的所有权语义和生命周期管理策略。

std::unique_ptr表示独占所有权，同一时间只能有一个unique_ptr指向某个对象；而std::shared_ptr则允许多个智能指针共享同一个对象的所有权，当最后一个共享该对象的智能指针被销毁时，对象才会被删除。

std::weak_ptr 是一种智能指针，通常不单独使用，只能和 shared_ptr 类型指针搭配使用，可以视为 shared_ptr 指针的一种辅助工具。借助 weak_ptr 类型指针可以获取 shared_ptr 指针的一些状态信息还可以解决shared_ptr 循环引用的问题。

## 计数器何时会改变？

智能指针内部有一个计数器，当赋值给别的智能指针或者函数传参拷贝到另一个shared_ptr，计数器就会加1，当函数执行完毕，智能指针对象 就被析构了，此时计数器就会减一，知道计数器变为0 ，说明没人在用这个对象了，就执行delete把它释放掉。

## 智能指针和管理的对象分别在哪个区？

智能指针本身：智能指针是一个类模板的实例，通常作为局部变量存在于栈区（Stack）。当函数返回或者局部变量超出其作用域时，栈区的内存会被自动释放。

智能指针管理的对象：智能指针通常用来管理在堆区（Heap）上分配的内存。这是通过调用如new操作符来完成的。堆区的内存会一直存在，直到显式地释放它（使用delete操作符）或者当程序结束时才会被系统回收。

智能指针的关键优势在于，它利用了栈对象（智能指针本身）超出生命周期后自动析构的特性。智能指针的析构函数会负责自动释放它所管理的堆区内存，因此开发者无需手动调用delete来释放资源。这大大减少了内存泄漏的可能性，因为即使在异常或复杂的控制流中，只要智能指针对象超出了其作用域，其析构函数就会被调用，进而释放内存。

## 循环引用

循环引用会在以下情况下产生：当两个或多个对象相互持有对方的智能指针（通常是shared_ptr）时，它们之间的引用计数将永远无法降到零，因为每个对象都在等待其他对象被销毁以释放自己。这种情况下，即使这些对象不再被程序的其他部分使用，它们所占用的内存也无法被释放，从而导致内存泄漏。通过使用weak_ptr代替其中一个或多个shared_ptr，可以打破这种循环引用，确保对象在不再需要时能够被正确销毁。

std::weak_ptr的主要使用场景是解决循环引用问题。例如，在一个树或图数据结构中，父节点和子节点可能相互引用，这就可能导致循环引用。为了避免这种情况，可以将父节点使用weak_ptr来管理，而子节点使用shared_ptr来管理。这样，当子节点被销毁时，父节点的weak_ptr会自动失效，而不会导致父节点无法被销毁。


# 面向对象特性

## 多继承中的内存分布

一个没有虚函数的类，它的大小其实就是所有成员变量的大小，此时它就是一个由诸多成员变量组成的结构体，计算大小时同样要按照字节对齐去计算。

一个没有虚函数的类派生出一个没有虚函数的派生类，那么这个派生类的内存布局就是先基类成员变量，然后派生类成员变量组成的结构体，各成员变量在内存中存储顺序按照声明时的顺序来存放。

一个有虚函数的类，类本身会生成一份虚函数表，这个虚函数表是所有类对象共享的，每个类对象都会在构造时首先生成一个虚表指针，指向这个虚函数表，然后才是各个成员变量，所以有虚函数的类对象会比没有虚函数的类多一个虚表指针。

一个派生类非虚继承于一个有虚函数的类，不论派生类是否有同样的虚函数，它的内存布局都只是在有虚函数的基类基础上增加派生类的成员变量，虚表指针是直接继承基类的，指向基类虚表指针，如果派生类有同样的虚函数，那就覆盖基类虚表中同名函数。如果是派生类独有的虚函数，那就追加在基类虚函数表后面。

一个派生类虚继承于一个有虚函数且有成员变量的基类，此时派生类会重新生成它自己的虚表指针和虚函数表，内存布局则是派生类的虚表指针和成员变量在前，基类的虚表指针和成员变量在后；


## 多态原理

多态即：一个对外接口，多种内在实现形式。

多态性的实现主要依赖于虚函数和动态绑定。编译器在编译时，会为包含虚函数的类创建一个虚函数表和虚函数指针。虚函数表是一个一维数组，其中存放了每个虚函数的地址。程序运行时，会根据对象的实际类型来初始化虚函数指针，使其指向所属类的虚函数表。这样，在调用虚函数时，就可以根据函数地址找到正确的函数。

多态允许我们将子类的对象当作父类的对象使用，即某父类型的引用指向其子类型的对象，调用的方法是该子类型的方法。这种机制使得我们可以使用统一的接口来处理不同的对象，提高了代码的复用性和可扩展性。

## 虚函数表的个数

每个含有虚函数的类都会有一个虚函数表： 如果类定义或继承了虚函数，编译器会为该类生成一个虚函数表。这个表包含了指向类虚函数实现的指针。

派生类覆写基类的虚函数： 它会在自己的虚函数表中更新该函数的入口。这确保了使用基类指针或引用调用虚函数时，执行的是派生类中最新的函数实现。

当一个类有多个基类时，且每个基类都有自己的虚函数表： 派生类将继承所有这些虚函数表。如果派生类覆写了任何继承的虚函数，它会在继承来的表上进行修改。如果派生类增加了新的虚函数，则会追加到现有的虚函数表。


## 虚函数

虚函数允许子类重新定义父类中的方法，并按照子类的需求来实现，从而实现多态性。

虚函数的实现主要依赖于动态联编，也就是在运行时决定调用哪个函数。这与普通的函数调用（静态联编）不同，后者在编译时就已经确定了要调用的函数。虚函数的原理是将函数调用的控制权交给运行时环境，而不是编译时环境。因此，虚函数的实现需要在运行时才能确定。

构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用，因此构造函数不能是虚函数。

析构函数建议设置为虚析构函数，防止内存泄漏。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。

## 多态和继承在什么情况下使用？

多态主要用于实现代码的复用和扩展性，允许使用通用的接口或抽象类来编写代码，而不依赖于具体的实现类。这样可以提高代码的复用性，减少代码的冗余，并在需要扩展功能时，可以通过添加新的实现类来实现，而无需修改现有的代码。多态还鼓励面向接口编程，将关注点从具体实现转移到接口定义的行为上。

继承则主要用于实现代码复用和扩展现有类的功能。通过继承，一个类（子类或派生类）可以继承另一个类（父类或基类）的属性和方法，避免重复编写代码，提高代码的复用性和可维护性。

## 除了多态和继承还有什么面向对象方法？

封装：将数据（变量）和对数据的操作（方法）组合在一起，形成所谓的“对象”。通过封装，我们可以隐藏对象的内部状态和实现细节，只对外暴露必要的接口。这增加了数据的安全性和代码的可维护性。

抽象：从具体的实例中提取共同性质，形成一般的概念或类。通过抽象，我们可以定义类的属性和方法，从而实现代码的复用和简化。此外，抽象类和接口也是实现抽象的重要手段，它们允许我们定义方法的规范，而不必提供具体的实现。

组合和聚合：组合和聚合是面向对象编程中用于构建复杂对象的重要方法。通过组合，一个对象可以包含其他对象作为其属性。而聚合则是一种特殊的组合关系，表示整体与部分的关系。这些方法使得我们可以构建具有复杂结构和行为的对象。

设计模式：设计模式是在软件开发中解决特定问题的最佳实践。它们提供了经过验证的解决方案，可以帮助我们更高效地设计和组织代码。常见的面向对象设计模式包括单例模式、工厂模式、观察者模式等。

# C++内存分布
## 栈区 堆区

栈区：栈是由编译器自动分配和释放的，主要用于存放局部变量和函数参数。它的特点是存取速度快，但是空间大小有限。当函数被调用时，其参数和局部变量会被压入栈中，当函数返回时，这些变量又会从栈中弹出。因此，栈中的数据在函数执行完毕后会自动被清除。

堆区：堆是用于动态内存分配的区域，程序员通过new或malloc等函数申请内存，通过delete或free等函数释放内存。堆的内存分配和释放都是由程序员来控制的，空间大且灵活，可以容纳大量或任意大小的数据。

全局/静态存储区：全局变量和静态变量（包括静态全局变量、静态局部变量和静态类成员变量）都存放在这个区域。它们的生命周期是整个程序的运行期间。

常量存储区：这个区域存放的是常量，一旦赋值后就不能改变。

## RAII

在对象的构造函数中获取资源，在析构函数中释放资源。这样，当对象的生命周期结束时，其析构函数会被自动调用，从而确保资源得到正确释放。智能指针内部实现了RAII原则。

# C++从源程序到可执行程序的过程

预处理：编译器首先读取源程序。预处理器处理源文件中的预处理指令，如#include、#define等#include指令告诉预处理器将指定的头文件内容插入到源文件中。

编译：将预处理后的代码转换为汇编语言代码。这个过程包括词法分析、语法分析、语义分析以及中间代码生成。

汇编：汇编器将汇编代码转换为机器代码，也就是目标文件（.o）

链接：链接器将多个目标文件以及所需的库文件合并成一个可执行文件，如果程序中引用了某个库中的函数或变量，链接器会找到这个库，并将相应的代码段添加到最终的可执行文件中。

加载和执行：当操作系统加载并执行这个可执行文件时，它会将程序加载到内存中，并设置程序的执行环境。然后，CPU开始执行程序中的机器指令。

# 一个对象=另一个对象会发生什么？

一个对象赋值给另一个对象时，并不会创建一个全新的对象，而是会修改已有的对象。实际上调用的重载函数“=”，而不是拷贝操作。赋值操作会修改被赋值的对象，使其具有与赋值源对象相同的值，但不会创建新的对象实例。

# new之后出问题直接return，会导致内存泄漏，怎么解决？

使用智能指针和RAII原则，可以确保即使在发生异常或提前返回的情况下，动态分配的内存也能得到正确的释放，从而避免内存泄漏。

# 多进程fork后不同进程会共享哪些资源？

多进程编程中，当使用fork系统调用创建一个新的进程（子进程）时，子进程是父进程的副本。这意味着子进程会获得父进程数据空间、堆和栈的副本，并且会继承父进程打开的文件描述符。

打开的文件：父进程打开的所有文件描述符都会在子进程中得到保存。这意味着子进程可以访问和操作这些文件，而父进程同样可以。

环境变量：父进程的环境变量也会被子进程继承。这些环境变量通常包含了程序运行所需的配置信息。

共享内存段：如果父进程有任何共享内存段，子进程也会共享这些内存段。共享内存允许不同进程访问同一块内存区域，从而实现进程间的通信。

然而，虽然子进程获得了父进程的一些资源副本，但父子进程之间仍然保持独立。例如，它们的进程ID、内存地址空间是不同的。子进程对资源的修改不会影响到父进程。

# 多线程里线程的同步方式

## 锁机制

互斥锁（Mutex）：互斥锁是最基本的线程同步机制之一。当一个线程拥有某个互斥锁时，其他线程无法获得该锁，从而保证了同一时刻只有一个线程可以访问共享资源或执行某段代码。

读写锁（ReadWriteLock）：读写锁适用于读操作远多于写操作的场景。多个线程可以同时持有读锁进行读取，但只有一个线程可以持有写锁进行写入。这提高了并发性能，同时保证了数据的一致性。

条件变量（Condition Variable）：条件变量通常与互斥锁一起使用，允许线程等待某个条件成立。当条件不满足时，线程会释放锁并进入等待状态；当条件满足时，另一个线程会通知等待的线程，使其重新获得锁并继续执行。

条件变量工作原理：当线程需要等待某个条件成立时，它会调用条件变量的等待（wait）函数，并释放之前持有的互斥锁。这样，线程会进入阻塞状态，等待其他线程发出通知。当其他线程满足了该条件时，它会调用条件变量的通知（notify_one）或广播（notify_all）函数来唤醒一个或多个等待中的线程。
这些等待中的线程会重新获取互斥锁，并检查条件是否真正满足。

## 原子操作


C++11引入了原子操作的概念，提供了多种原子操作数据类型，如atomic ，在多线程中对这些类型的共享资源进行操作，编译器将保证这些操作都是原子性的。能像mutex一样保证线程安全，但是atomic的操作是原子性的，不用使用锁，提高了效率。

## 信号量

信号量是一个非负整数，用于控制对共享资源的访问。线程通过减少信号量的值来请求资源，如果信号量值为零，则线程会被阻塞；当其他线程释放资源并增加信号量值时，被阻塞的线程会被唤醒。

# size_of是在编译期还是在运行期确定？

sizeof是在编译期确定的。在C语言中，sizeof是一个编译时一元运算符，用于计算数据类型或表达式的大小（以字节为单位）。它返回一个size_t类型的值，表示操作数所占用的内存大小。在编译时，编译器就已经确定了所有对象或类型的大小，因此sizeof的值也是在编译期确定的。

## 静态多态有什么

静态多态是指在编译期确定函数的调用方式，也称为编译时多态。其主要实现方式是函数重载和运算符重载。

# 函数重载的机制

其允许在同一作用域内定义多个同名函数，但这些函数的参数列表（包括参数的类型、个数或顺序）必须不同。函数重载的确定发生在编译期，而不是运行期。编译器会根据调用时提供的参数自动匹配并执行相应的函数版本。

与函数重载不同，函数重写（Overriding）是父类与子类之间多态性的一种表现，它发生在运行期。当子类重写了父类的方法，并且有子类对象引用时，具体调用哪个版本的方法是在运行时决定的，取决于对象的实际类型。这种动态选择最合适版本的方法的过程称为动态绑定

# 指针常量和常量指针

指针常量本质上一个常量，指针自身的值是一个常量，不可改变，始终指向同一个地址。在定义的同时必须初始化。

常量指针本质上是一个指针，指针指向的内容是不可改变的，指针看起来好像指向了一个常量。

# const

只要一个变量前用const来修饰，就意味着该变量里的数据只能被访问，而不能被修改，即意味着“只读”（readonly）。使用const可以在一定程度上提高程序的安全性和可靠性。

修饰局部变量和全局变量：无论是全局变量还是局部变量，只要被const修饰，其值都不能被改变。

修饰函数的参数和返回值：确保函数内部不会修改传递进来的参数值，或者确保返回的值不会被修改。

const成员函数：它表示该函数不会修改任何成员变量（除了被声明为mutable的成员变量）。

虽然const修饰的变量在语义上被认为是不可变的，但在某些情况下，通过指针的间接引用还是有可能修改其值

## const和define区别

#define是C和C++中的预处理指令，用于创建符号常量。使用#define定义的常量是一种简单的文本替换，编译器会在预处理阶段将所有的符号常量替换为其定义的值，不会为其分配内存，也不会进行类型检查。

const常量可以进行类型检查，声明的常量在内存中有自己的存储位置，编译器会为其分配内存空间。可以修饰变量、函数参数以及函数返回值。


# 引用和指针的区别

引用在定义时必须初始化，且一旦初始化后，就不能再指向其他对象。引用与其所引用的对象之间的绑定是固定的，且不可改变。而指针则可以在任何时候改变其所指向的对象，指针可以指向不同的内存地址。

引用的大小通常与它所引用的变量的大小相同，因为引用本身只是原变量的一个别名。而指针的大小则通常固定，与它所指向的变量的大小无关

从安全性的角度来看，引用比指针更安全。由于引用一旦被初始化后就不能改变，因此不存在空引用或引用未初始化的风险。而指针则可能指向空地址或未初始化的内存。

从使用的灵活性来看，指针提供了更多的操作选项，例如指针运算（如指针加减）和多级指针等，而引用则没有这些特性。

# char* 和int *各占几个字节？

指针的大小不取决于它指向的数据类型，而是取决于系统的位数。指针的大小足够存储内存地址，而不受它指向的数据类型的影响。在大多数32位系统中，指针占用4个字节。在大多数64位系统中，指针占用8个字节。

# C代码中引用C++代码有时候会报错，为什么？

名称空间问题：C语言没有命名空间的概念，而C++有。因此，在引用C++代码时，需要使用特定的方式指定命名空间。如果未正确指定命名空间，则会出现名称冲突和编译错误。

C++特有的关键字：C++中有一些关键字（如new、delete等）是在C语言中不存在的，因此在引用C++代码时需要注意这些关键字是否与C语言中已存在的标识符重复。

类型转换问题：由于C和C++对类型转换的机制不同，因此在引用C++代码时需要注意类型转换是否正确。

编译器差异：由于不同编译器实现不同，在编译混合代码时可能会遇到一些编译器相关的问题。

为了解决这些问题，可以采取以下措施：

- 在头文件中使用extern “C”声明来告知编译器该部分为纯粹的“C”语言，以免发生函数命名错误或者变量名重复等情况。
- 将被调用函数放入一个独立的源文件中进行编写，并将其链接到应用程序。
- 在调用 C++ 函数时尽量不要涉及 C++ 特有的内容（例如类、模板等），尽可能地使用 C 风格的语言特性，以免出现类型转换问题。
- 确保使用相同版本的编译器和链接器，并且在项目中使用统一的编译选项。


# inline 失效场景

函数体过大：如果函数的代码长度非常长，编译器可能会拒绝将其视为 inline 函数，因为这样会增加编译时间并且可能增加目标代码的大小。

复杂的控制流程：对于含有循环、递归、条件判断等复杂控制流程的函数，编译器可能会拒绝将其标记为 inline，因为直接插入代码可能导致代码膨胀和无法正确执行。

构造函数和析构函数：编译器通常不会将构造函数和析构函数标记为 inline，因为它们的代码长度通常不宜短，并且通常在类型创建和销毁时使用。

跨编译单元的 inline 函数：如果一个 inline 函数在多个编译单元中定义，且每个编译单元都需要它，编译器可能会为每个编译单元生成一个独立的内联展开版本

虚函数和继承：虚函数不能被内联，因为它们的调用必须在运行时确定。同样，如果一个函数是虚拟的或者是抽象基类中定义的，那么它也不能被内联。

优化关闭：如果编译器被设置为关闭优化，那么 inline 请求可能不会被接受，因为没有优化，直接插入代码可能不会带来任何性能提升。

模板函数：对于模板函数，如果它们在编译时不能被实例化，那么 inline 请求可能会失效，因为编译器无法在调用点展开代码。

# C++ 中 struct 和 class 区别


在struct中，默认的访问权限是公共的（public）。在class中，默认的访问权限是私有的（private）。
在struct中，基类默认是公共继承的。在class中，基类默认是私有继承的。

一般来说，struct用于轻量级的对象，比如只包含数据成员而没有复杂的函数成员的情况下。
class则更多用于有复杂内部逻辑的对象，比如需要私有数据成员并且有复杂的操作函数。

# 友元friend

在某些情况下，类向不属于类成员的函数或单独类中的所有成员授予成员级访问权限非常有用。 这些自由函数和类称为“友元”，由 friend 关键字标记。以允许其访问类的私有和受保护成员。 

好处：可以提高编程的灵活性和程序执行效率；

坏处：破坏了类的封装机制。

# 模版类的作用

模板类是C++中的一种泛型编程技术，其编写一个通用的类定义，可以用于不同的数据类型。模板类在编译时根据给定的类型参数生成特定类型的类实例，这种技术称为编译时多态。

模板是泛型编程的基础。模板是创建类或者函数的公式。

# new和malloc的区别

new 是c++中的操作符，malloc是c 中的一个函数。

new 不止是分配内存，而且会调用类的构造函数，同理delete会调用类的析构函数，而malloc则只分配内存，不会进行初始化类成员的工作，同样free也不会调用析构函数。

内存泄漏对于malloc或者new都可以检查出来的，区别在于new可以指明是那个文件的那一行，而malloc没有这些信息。

new 返回指定类型的指针，并且可以自动计算所需要大小。而 malloc 则必须要由我们计算字节数，并且在返回后强行转换为实际类型的指针。 　

## new重载

operator new是一个操作符，和 + - 操作符一样，作用是分配空间。可以重写它们，修改分配空间的方式。

operator new返回值必须是void*。第一个参数必须是size_t。

operator new重载可以放在全局中，也可以放到类内部。当编译器发现有new关键字，就会现在类和其基类中寻找operator new，找不到就在全局中找，再找不到就用默认的。

在类中的operator new默认就是static。

## delete和delete[]的区别

delete 用于释放单个对象（非数组）所占用的内存。如果动态分配的内存是通过 new 操作符分配的单个对象，那么在释放内存时应该使用 delete。

delete[] 用于释放通过 new[] 操作符分配的数组所占用的内存。delete 无法正确处理数组类型的内存释放，可能会造成内存泄漏。

# extern C有什么作用

extern "C"关键字常用于C++和C混合编程中，用于指定函数或变量采用C语言的命名和调用约定。加上extern "C"后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。

由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名（而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名）。
