# 内存泄漏？怎么解决？

内存泄漏是指程序在动态分配内存后，未释放或者未能完全释放该内存空间的情况。这样会导致内存不断被占用，进而导致程序性能下降、甚至崩溃等问题。

可以通过以下几个步骤来解决内存泄漏问题：

- 排查代码：查看代码中是否有明显的内存泄漏的情况，例如忘记释放内存等。
- 使用工具检查：可以使用一些内存泄漏检测工具，例如Valgrind、Purify、AddressSanitizer等，来检测程序中的内存泄漏情况。
- 检查资源的使用情况：程序中除了内存泄漏还可能存在其他资源泄漏，例如文件句柄、网络连接等，需要逐一检查并进行相应的释放。
- 使用智能指针：在C++中，可以使用智能指针（shared_ptr、unique_ptr、weak_ptr）等RAII技术来管理动态内存，自动释放资源，避免忘记释放内存的问题。

# 常见的内存泄漏都有哪些？

内存分配未释放：程序中使用了动态分配内存的函数分配内存，但没有调用函数进行释放。

大对象未分配内存池：如果需要频繁地分配、释放大对象（如数组、矩阵等），直接调用系统函数分配内存可能会导致内存碎片化，进而导致系统内存泄漏。

智能指针循环引用：当两个或多个对象之间互相引用时，它们会互相持有对方的引用，当这些对象中有一个引用没有被释放时，将导致内存泄漏。

# 如何避免内存泄漏？

对于需要长时间占用内存的程序，可以考虑采用内存池技术，动态分配一定数量的内存空间，在使用完成后放回内存池中，避免频繁申请和释放内存造成的性能影响。

使用智能指针，能够在对象不再被引用时自动释放内存。C++11引入了std::shared_ptr和std::unique_ptr等智能指针，可以有效避免内存泄漏。

在程序中处理异常情况时，要确保在异常发生时也能够正确释放资源，以防止异常情况导致资源泄漏。

使用内存泄漏检测工具，例如Valgrind等，来帮助检测和解决内存泄漏问题。

# 常见的内存错误

内存泄漏：指已经不再需要使用的内存没有被释放，导致内存浪费。

内存溢出：指分配的内存空间不足以满足当前需要，导致程序崩溃。

野指针：指指针指向了已经被释放的内存空间，或者指针未被初始化就被使用。

# 内存的两种分配方式

静态内存分配：在程序编译时就已经分配好内存，运行时不能改变分配的内存大小，程序执行速度快，但是空间利用率低，不能灵活分配内存空间。

动态内存分配：在程序运行时才分配内存，可以根据需要灵活地分配和释放内存空间。

# 栈和堆

栈存放程序的局部变量、函数参数和返回地址等信息。栈的内存空间由操作系统自动分配和释放，其空间大小是固定的，一般为几MB至几十MB。

堆是一种动态内存分配方式，程序员需要手动申请和释放堆内存，其大小可以动态增加或减少。

在程序运行过程中，栈的分配和释放速度较快，但栈的容量有限；堆的分配和释放速度较慢，但堆的容量较大。因此，对于较小的数据结构，优先使用栈来分配内存；对于较大的数据结构，需要动态管理内存时，可以使用堆来分配内存。

# 什么是内存对齐？

内存对齐是指将数据结构中的每个成员按照一定的规则进行排列，使得每个成员的起始地址相对于该结构的起始地址偏移量为该成员大小的整数倍。这样做的目的是为了让处理器在读取数据时更加高效，因为处理器可以一次性读取多个连续地址上的数据，如果数据不对齐，处理器就需要多次读取，降低了读取速度。

# 为什么要内存对齐？

当CPU从内存中读取数据时，如果数据没有按照规定的对齐方式进行存储，那么CPU需要分两次或更多次读取内存，这会增加CPU访问内存的时间和系统的开销。

此外，对于结构体等复合类型数据的内存存储，内存对齐还可以保证数据存储的安全性。如果数据没有按照规定的对齐方式存储，可能会导致数据被拆分存储在两个内存块中，这样会增加访问内存的复杂度，并且在多线程环境下可能会发生数据竞争的问题，导致数据的不一致性。



# C++内存对齐的使用场景

减少内存碎片：对齐可以保证结构体或类中的数据成员按照规则排列，避免因为数据成员的大小不一致而导致的内存碎片。

提高数据访问速度：由于现代计算机的内存访问是按照一定的块大小进行的，对齐可以保证数据成员按照块的大小进行存储，从而提高内存访问速度。

保证跨平台兼容性：不同的平台可能对内存对齐有不同的要求，使用内存对齐可以保证程序在不同平台上的运行效果一致。

# 内存对齐应用于哪几种数据类型及其对齐原则是什么？

内存对齐应用于三种数据类型中：struct、class、union；

数据成员的偏移量必须是对齐数的整数倍。对齐数指的是编译器为了满足对齐要求而添加的字节大小。例如，对于4字节对齐的结构体，其对齐数为4，数据成员的偏移量必须是4的整数倍。

# 如何进行内存对齐？

可以通过预编译命令#pragma pack(n), n= 1,2,4,8,16来改变对齐系数。


# void*指针有那些使用场景

内存分配和管理：void* 指针常用于动态内存分配函数（如 malloc、calloc、realloc）的返回值类型，可以用来指向分配的内存块。

函数参数传递：当函数需要接受任意类型的指针作为参数时，可以使用 void* 指针作为函数参数类型。

回调函数：在回调函数中，为了能够接受各种类型的参数，通常会使用 void* 指针传递数据或函数指针。

数据结构的通用性设计：有些数据结构（如链表、树等）可能需要存储不同类型的数据，此时可以使用 void* 指针作为数据项的类型，实现数据结构的通用性。

# int *p=null 与 int *p有什么区别？

int *p = null：在这种情况下，p 是一个指向整型数据的空指针，不指向任何有效的内存地址。

int *p：这是一个指针的声明，但没有进行初始化。在声明之后，指针 p 将包含一个未知的值，它可能指向任意地址，包括无效地址。



# 如何处理悬垂指针和野指针的问题？

悬垂指针是指在程序中使用了已经释放的内存地址。要避免出现悬垂指针，应该：

- 在释放动态分配的内存后，将对应的指针设置为nullptr或其他有效值。
- 避免在函数返回后返回局部变量的指针。

野指针：野指针是未初始化或者乱初始化的指针，它们可能会引发未定义行为。
- 在定义和声明时初始化所有指针，并及时给予其合法且有效的值。

# 指针参数是如何传递内存？

指针参数的传递是按值传递的，也就是传递的是指针变量的值，也就是数据的地址。函数中的指针参数是函数调用者的一个变量地址的副本，修改指针的值不会影响原始的指针变量。但是，修改指针所指向的内存地址中的内容，会直接影响原始变量的值。

# 内存碎片是什么？

内存碎片是指内存中存在大量不连续的、小块的未使用内存空间，这些空间不能被分配给大块的内存请求，从而导致系统无法满足内存请求的情况。

- 尽量避免频繁的内存分配和释放，可以采用对象池等技术来管理内存。
- 使用内存池技术，对一定大小范围内的内存进行预分配，避免频繁的内存分配和释放。
- 使用内存对齐技术，可以减少内存碎片的发生。

# 什么是段错误？

段错误（Segmentation fault）是指程序试图访问非法的内存地址，或试图对没有写权限的内存地址进行写操作时产生的错误。通常由于指针操作不当或者动态内存分配不当等原因引起。

# new运算符和malloc函数有什么区别？

类型安全性：new运算符是C++中的操作符，可以执行对象构造并返回指向相应类型的指针。它会根据类型自动计算所需的内存大小，并执行适当的初始化。而malloc()函数是C语言中的库函数，返回void*类型的指针，需要手动转换为特定类型，并没有对对象进行构造和初始化。

内存大小计算：使用new运算符时，编译器会自动根据所需类型计算分配内存的大小，无需显式指定。而使用malloc()函数时，需要手动指定要分配的内存大小（以字节为单位）。

异常处理：如果在使用new运算符时发生了错误（如内存不足），它会抛出一个异常 std::bad_alloc 来指示错误。而在使用 malloc() 函数时，则需要手动检查返回值是否为NULL来判断分配是否成功。

# 如何处理new操作失败的情况？

当new操作失败时，会抛出std::bad_alloc异常。

捕获异常并处理：在执行new操作时使用try-catch语句来捕获std::bad_alloc异常，并在catch块中进行适当的处理。例如：输出错误消息、释放其他资源或采取其他恢复措施。

使用nothrow参数：可以通过传递 std::nothrow 参数给 new 运算符来禁用它抛出异常的行为。如果内存分配失败，将返回一个空指针而不是抛出异常。

# 为什么要使用智能指针来管理资源?

自动内存管理：智能指针可以确保在不再需要时自动释放分配的内存，避免了忘记释放内存或手动删除内存造成的内存泄漏问题。

异常安全：当使用裸指针进行动态内存分配时，如果在分配后发生异常导致程序流程跳转到其他位置，可能会导致未释放的资源。而智能指针可以保证在异常发生时也会正确地释放已分配的资源，从而提供更强大的异常安全性。

# C++11引入了哪些新的智能指针类？

std::unique_ptr：独占所有权，不能进行复制或共享资源。可以通过移动而不是复制来转移资源的所有权。

std::shared_ptr：允许多个智能指针共享同一个资源，并使用引用计数来跟踪资源的生命周期。引用计数可能会带来一些额外开销，包括原子操作和内存消耗。当最后一个共享指针超出作用域或显式地重置时，才会释放所管理的资源。

std::weak_ptr：是对于std::shared_ptr 的一种弱引用，不增加引用计数。主要用于解决std::shared_ptr 循环引用的问题。

# 浅拷贝 深拷贝

主要是对于指针来说的。

浅拷贝： 浅拷贝是指创建一个新对象，并将原对象的成员变量的值复制给新对象的对应成员变量。这样，原对象和新对象会共享同一块内存空间，对其中一个对象进行修改会影响另一个对象。浅拷贝只复制了对象本身以及其指向的内存地址，而不是实际的数据。

深拷贝： 深拷贝是指创建一个新对象，并将原对象的成员变量的值复制给新对象的对应成员变量。不同于浅拷贝，深拷贝会为新对象分配一块独立的内存空间，将原对象中的数据复制到这个新内存中。

# 如何防止对象被复制或赋值？

将拷贝构造函数和赋值操作符重载函数声明为私有，并不实现它们。这样一来，类外部无法调用这些函数。

=delete，显式地禁止编译器自动生成某些函数。