# 数组和链表区别和优缺点

数组是一种线性数据结构，用于存储相同类型元素的集合。在内存中，数组是连续存储的。

优点：数组支持通过索引快速访问任何元素，时间复杂度为O(1)。由于数组元素在内存中是连续存放的，这有利于CPU缓存机制，可以提高访问速度。

缺点：大多数语言中的数组在初始化时大小固定，之后不能动态增长或缩减。在数组中间插入或删除元素需要移动大量元素，时间复杂度为O(n)。

链表是一种线性数据结构，由一系列不必在内存中连续存储的元素组成，每个元素都指向下一个元素。

优点：链表的大小可以根据需要动态增长或缩减，不需要在初始化时确定大小。在链表中插入或删除一个元素时，只需要改变相应的指针，时间复杂度为O(1)，如果是在链表中间插入或删除，需要先搜索到相应位置，搜索时间复杂度为O(n)，但实际插入和删除操作仍为O(1)。

缺点：链表不支持直接通过索引访问元素，访问任何元素都需要从头开始遍历，平均时间复杂度为O(n)。每个元素都需要额外的存储空间来存储指向下一个元素的指针。

数组更适用于需要频繁访问元素的场景，或者当元素数量事先已知且变化不大时。链表则更适用于元素数量频繁变化，或者需要频繁进行插入和删除操作的场景。

# 快速排序


快速排序是一种高效的排序算法，使用分治法的策略来对数组进行排序。它的基本逻辑可以分为三个主要步骤：挑选基准值、分区、递归排序。

首先要从数组中挑选一个元素作为基准值(pivot)。基准值的选择可以有多种方式，比如总是选择第一个元素、最后一个元素、中间元素。

一旦基准值被选定，数组会被重新排列，所有比基准值小的元素都被移动到基准值的前面，所有比基准值大的元素都被移动到基准值的后面。基准值就处于其最终位置。

最后，通过递归调用快速排序算法，分别对基准值左右两边的子数组进行排序。快速排序的效率来自于它能够快速将数组分成较小的部分，并独立地排序这些部分。其平均时间复杂度为O(n log n)，但在最坏情况下（例如，当数组已经是正序或逆序时）时间复杂度会退化到O(n^2)。

```cpp
class Solution {
private:
    int find_p(vector<int>& nums, int l, int r) {
        int mid=(l+r)/2;
        swap(nums[l],nums[mid]);
        int pivot = nums[l];
        while(l<r){
            while(l<r&&nums[r]>=pivot) r--;
            nums[l]=nums[r];
            while(l<r&&nums[l]<=pivot) l++;
            nums[r]=nums[l];
        }
        // l和r重合了
        nums[l]=pivot;
        return l;
    }
    void quick(vector<int>& nums, int l, int r) {
        if (l < r) {
            int pivot = find_p(nums, l, r);
            quick(nums, l, pivot - 1);
            quick(nums, pivot + 1,r);
        }
    }
public:
    vector<int> sortArray(vector<int>& nums) {
        quick(nums, 0, nums.size() - 1);
        return nums;
    }
};
```

# 堆排序

从最后一个非叶子节点开始（即最后一个节点的父节点），对每个非叶子节点进行调整，确保子树都是最大堆。如果节点的值小于其子节点的值，则需要将节点与其最大的子节点进行交换，并继续检查交换后的子节点是否满足最大堆的条件。通过自底向上的方式对所有非叶子节点执行下沉调整，直到根节点，这样就能构建出一个最大堆。

将根节点（即当前最大值）与堆的最后一个元素交换，然后断开最后一个元素（将其从堆中删除，此时它已经放置到其最终位置）。对剩下的堆进行调整，以恢复最大堆的属性。

```cpp
void heapify(std::vector<int>& arr, int n, int i) {
    int largest = i; // 初始化最大为根
    int left = 2 * i + 1; // 左子节点
    int right = 2 * i + 2; // 右子节点
    // 如果左子节点大于根
    if (left < n && arr[left] > arr[largest])
        largest = left;
    // 如果右子节点比最大的还大
    if (right < n && arr[right] > arr[largest])
        largest = right;
    // 如果最大不是根
    if (largest != i) {
        std::swap(arr[i], arr[largest]);
        // 递归地定义子树
        heapify(arr, n, largest);
    }
}

void heapSort(std::vector<int>& arr) {
    int n = arr.size();
    // 构建最大堆
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);
    // 一个个从堆顶取出元素
    for (int i = n - 1; i >= 0; i--) {
        // 移动当前根到数组的末尾
        std::swap(arr[0], arr[i]);
        // 调用max heapify在减少的堆上
        heapify(arr, i, 0);
    }
}
```
# 排序算法： 哪些是稳定的，哪些不稳定的

稳定排序：
- 冒泡排序：通过重复交换相邻逆序的元素，使得较大的元素逐渐移至数组的后端。
- 插入排序：每次将一个待排序的元素，插入到前面已经排序的序列中的合适位置上。
- 归并排序：将数组分成两半，分别对它们排序，然后合并成一个有序数组。
- 桶排序：将数组分到有限数量的桶里，对每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。
- 基数排序：按照低位先排序，然后收集；再按照高位排序，然后再收集，以此类推，直到最高位。

不稳定的排序算法：
- 选择排序：每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置。
- 快速排序：通过选取一个元素作为基准，将待排序集合分成两个子序列。
- 堆排序：利用堆这种数据结构所设计的一种排序算法。
- 希尔排序：也称递减增量排序算法，是插入排序的一种更高效的改进版本，不稳定。


# 千万级数组如何求最大k个数？

对于找到最大的k个数，可以将数组分成若干小块，先在每个小块中找到最大的k个数，然后合并这些小块的结果，再从合并后的结果中找到最大的k个数。

# hash解决冲突

开放定址法：通过在哈希表中寻找空闲位置来解决冲突。如果一个数据项的哈希地址已经被占用，则按照某种系统的方法，寻找下一个空闲的地址。（线性探测，二次探测，双重散列）。缺点是可能产生聚集现象，即连续的数据项聚集在表中的某个区域，这会降低查找效率。

链地址法：将所有哈希到同一个值的数据项存储在同一个链表中。哈希表的每个槽位关联一个链表，所有散列值相同的元素都被添加到同一个链表中。在分布均匀的情况下，插入、删除、查找操作的时间复杂度接近O(1)。其主要缺点是需要额外的内存空间来存储指针。

再哈希法：使用多个哈希函数，当发生冲突时，尝试另一个哈希函数，直到找到空槽为止。这种方法要求设计多个好的哈希函数，且这些哈希函数应该相互独立，以避免产生模式。缺点是计算成本较高，特别是当哈希函数复杂时。

建立公共溢出区：为哈希表预留一个或多个溢出区域，所有冲突的元素都存储在这个区域。主表中的每个槽可以存储一个指向溢出区中元素的指针。公共溢出区的优点是实现简单，容易理解。缺点是当溢出区填满后，可能需要额外的机制来处理新的冲突。

# hash表数据很大。rehash的代价很高，怎么办

渐进式重新哈希:其基本思想是将重新哈希的过程分散到对哈希表的每次操作（如插入、删除、查找）中去，而不是一次性完成所有的重哈希操作。

当哈希表需要扩容时，先创建一个新的空哈希表。在每次哈希表操作时，将一小部分旧哈希表中的元素移动到新哈希表中。同时，对新的插入操作，直接在新哈希表中进行。经过一系列操作后，旧哈希表中的元素逐渐被移动到新哈希表中，最终完成整个重哈希过程。

连锁哈希表（也称为哈希表中的链表法）可以减轻单个大规模重哈希操作的需要。通过在每个桶中保持一个链表，即使发生哈希碰撞，数据也可以被有效地存储。

这种方法虽然不直接减少重新哈希的需要，但可以使哈希表在更高的填充率下仍然保持较好的性能，从而推迟重哈希操作的发生。当必须进行重哈希时，渐进式重哈希同样可以与之结合使用，以分摊重哈希成本。

# 千万数据范围有限，0到1000，有很多重复的，按频率排序怎么处理？

创建一个长度为1001的数组（因为数据范围是0到1000），用于统计每个数字的出现次数。数组的索引对应数字的值，数组的元素值对应该数字出现的次数。

将频率数组转换为一个元素为(数字, 频率)对的列表，使用自定义排序。

# 布隆过滤器

布隆过滤器通常由一个位数组和多个哈希函数组成。当一个元素被加入到布隆过滤器时，会通过多个哈希函数将其映射到位数组的多个位置上，并将这些位置设置为1。当需要查询一个元素是否存在于布隆过滤器中时，同样会通过多个哈希函数计算其位置，并检查这些位置上的值是否都为1，如果存在任意一个位置为0，则可以确定该元素一定不在集合中；如果所有位置都为1，则该元素可能存在于集合中，但也有可能是误判。

- 空间效率高： 布隆过滤器只需要使用一个比特数组和多个哈希函数，所占用的空间相对较少。
- 查询效率高： 查询一个元素是否存在于布隆过滤器中的时间复杂度为O(k)，其中k是哈希函数的个数，通常情况下k是一个较小的常数。
- 插入效率高： 插入一个元素到布隆过滤器中的时间复杂度也为O(k)，与查询相同。

但是，布隆过滤器也有一些缺点：
- 存在误判： 布隆过滤器可能会将一个不属于集合的元素误判为存在于集合中，但不会将一个存在于集合中的元素误判为不存在。
- 无法删除元素： 布隆过滤器中的元素一旦被加入，就无法被删除，因为删除一个元素会影响到其他元素的判断结果。

## 不适用场景

精确性要求高： 布隆过滤器存在一定的误判率，即可能会将一个不属于集合的元素误判为存在于集合中。如果应用场景对于判断的准确性要求非常高，那么布隆过滤器可能不太适用。

无法删除元素： 一旦一个元素被加入到布隆过滤器中，就无法从中删除。这对于一些需要频繁变动数据集的场景不太适用，因为如果数据集经常变动，误判率可能会逐渐增加。

无法支持范围查询： 布隆过滤器只能用于判断一个元素是否存在于集合中，而不能支持范围查询或其他复杂查询操作。

# 红黑树，AVL树，B+树的区别

红黑树是一种自平衡的二叉搜索树，通过在每个节点上增加一个额外的位来存储节点的颜色（红色或黑色），并且满足以下性质：
- 每个节点要么是红色，要么是黑色。
- 根节点是黑色。
- 每个叶子节点（NIL 节点，空节点）是黑色。
- 如果一个节点是红色，则它的两个子节点都是黑色（红黑树的关键性质）。
- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

AVL树是一种高度平衡的二叉搜索树，它满足以下性质：
- 对于树中的每个节点，左子树和右子树的高度之差（平衡因子）最多为 1。

B+树是一种多路搜索树，节点通常具有更多的子节点。
- 内部节点存储键值和子节点指针，但不存储数据。
- 叶子节点存储键值和对应数据。

红黑树常用于实现关联容器，如 C++ 中的 std::map 和 std::set。由于 AVL 树的严格平衡性，适合用于需要严格控制树高度的场景，如数据库索引。B+树通常用于数据库和文件系统中，以支持范围查询和顺序访问。