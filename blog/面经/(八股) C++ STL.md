# vector

## vector的原理

std::vector是一个动态数组，它能够自动调整自身大小以容纳其内部存储的元素。std::vector的实现通常基于动态数组的概念，它通过动态分配内存来存储元素，并在需要时动态扩展内存空间以容纳更多的元素。

## 怎么扩容？

当需要扩容时，std::vector会申请一块更大的内存空间，并将原有元素拷贝到新的内存空间中。通常情况下，std::vector会将容量扩大为当前容量的两倍，以避免频繁的扩容操作。然后，释放旧的内存空间。

# queue

## 优先队列 priority_queue

std::priority_queue 是 C++ 标准模板库 (STL) 中的一种容器适配器，它提供了队列的功能，其中的元素按优先级出队。其底层实现通常是一个堆（heap）。

堆是一种特殊的完全二叉树，满足子节点的键值总是大于或等于（在最大堆中）或小于或等于（在最小堆中）其父节点的键值。

默认情况下，std::priority_queue 使用 std::vector 作为其底层容器来实现堆，并使用 std::less<T> 作为比较函数，这意味着元素将按照降序排列，即最大的元素被视为优先级最高。



# map

## map的原理

std::map是一种关联容器，用于存储键-值对，并根据键来进行快速查找。std::map基于红黑树实现，键值对会按照键的顺序在红黑树中进行排序。

红黑树具有以下性质：

- 每个节点要么是红色，要么是黑色。
- 根节点是黑色。
- 每个叶子节点（NIL节点，即空节点）都是黑色的。
- 如果一个节点是红色的，则它的子节点必须是黑色的（不能有连续的红色节点）。
- 从任意节点到其每个叶子节点的所有路径都包含相同数量的黑色节点（保持黑色高度相等）。

## 为啥用红黑树不用avl树？

红黑树是一种非严格平衡的二叉搜索树，而AVL树是一种严格平衡的二叉搜索树。这意味着在插入或删除节点时，红黑树允许树的不平衡程度稍高一些，而AVL树则需要通过旋转操作来严格保持平衡。这种差异导致了红黑树在插入和删除操作上的性能通常略优于AVL树，因为红黑树在维护平衡方面的开销较小。

其次，红黑树的实现相对简单一些，这有助于减少实现错误并提高代码的可读性。虽然AVL树提供了更严格的平衡保证，但这种严格性也带来了更高的实现复杂性和潜在的维护成本。

最后，对于map来说，其主要目的是提供一种有序的键值对存储结构。红黑树的有序性正好满足了这一需求，而且由于其高效的插入和删除性能，使得map在实际使用中具有良好的性能表现。

## 与unordered_map的区别

unordered_map则使用哈希表作为其底层数据结构，以提供更快的查找性能，但牺牲了元素的顺序性。

## 与multimaps的区别

multimaps是关联式容器，它按照特定的顺序，存储由key和value映射成的键值对<key, value>，其中多个键值对之间的key是可以重复的，multimap在底层用二叉搜索树(红黑树)来实现。

在内部，multimap中的元素总是通过其内部比较对象，按照指定的特定严格弱排序标准对key进行排序的。和map最大的区别，multimap中的key是可以重复的。

 multimap中没有重载operator[]操作，无法使用 multimap[key]进行访问数据。
 

## map和unordered_map的线程安全

map和unordered_map本身并不是线程安全的。这意味着在多线程环境下，如果没有适当的同步机制，同时对这两个容器进行读写操作可能会导致数据竞争和未定义行为。

为了在多线程环境中安全地使用map或unordered_map，需要实现线程安全的版本。

对于map，你可以通过封装std::map并使用std::mutex互斥锁来实现线程安全的版本。提供插入、获取、删除等线程安全的操作，有效解决了潜在的竞态条件和数据一致性问题。

对于unordered_map，由于它是基于哈希表实现的，可以使用C++11标准库中的std::shared_mutex来实现读写锁。这允许多个线程同时读取unordered_map，但只允许一个线程写入unordered_map，从而提高并发性能。


