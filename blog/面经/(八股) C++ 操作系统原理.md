# 中断对于操作系统的作用

中断是计算机硬件向CPU发出的一种异步信号，用于通知CPU发生了某些事件或需要处理某些任务。在操作系统中，中断被广泛应用于各种设备驱动程序和进程调度等方面。

当一个进程请求进行IO操作或者受到外部事件触发时，例如键盘输入、网络接收等，会向操作系统发送一个中断信号。操作系统通过中断处理程序来响应这个信号，并根据具体情况将其转化为相应的进程调度或设备驱动程序等操作。

# ELF文件格式

ELF（Executable and Linkable Format）文件格式是Linux系统下可执行文件和目标文件的标准格式。它包含了代码、数据、符号表、重定位信息等，并且支持动态链接，即可执行程序在运行时才加载所需库。

## 与.o文件的区别

ELF是一种文件格式标准，用于描述可执行文件、共享库文件和目标文件等。.o文件是编译器生成的目标文件，包含了编译后的代码和符号信息，但尚未链接成可执行文件或共享库。



# 线程、进程、协程的区别

进程：是程序的一次执行过程，是一个正在运行的程序的实例。每个进程都有自己的地址空间、内存、数据栈等系统资源。

线程：是进程中的一个实体，是程序执行流的最小单元，一个进程可以包含多个线程，共享该进程的地址空间和其他系统资源。

每个进程有独立的地址空间和系统资源，进程之间的通信和资源共享需要特殊的机制。线程共享所属进程的地址空间和其他系统资源，因此线程间通信和资源共享相对容易。

创建和销毁进程的开销比较大，因为需要分配和释放独立的内存空间和系统资源。创建和销毁线程的开销相对较小，因为线程共享所属进程的资源，只需分配线程的栈空间即可。

进程切换时需要保存和恢复整个进程的状态，切换开销较大。线程切换时只需保存和恢复线程的状态，切换开销相对较小。

协程是一种用户态的轻量级线程，它由程序员控制调度，而不是由操作系统调度。协程可以看作是在一个线程内部，通过特定的语法实现的多个执行流程，它们共享线程的状态。切换开销比线程更小，因为切换时不涉及操作系统的内核态和用户态的切换，而是在用户态完成。

## 应用场景


多进程场景。适用于那些不同任务之间无需进行大量交互、上下文切换不频繁的场景。例如，守护进程、多个独立的服务进程等。多进程模型可以防止单个任务崩溃导致整个服务崩溃。

多线程场景。适用于需要频繁修改数据、不同任务间需要大量共享数据或频繁通信的情况。此外，对于非CPU密集型的任务，如事件响应、桌面软件等，多线程可以提高响应速度和降低时延。


# 死锁的概念

死锁是指在并发系统中，两个或多个进程或线程因争夺资源而处于永久阻塞的状态，彼此都在等待对方释放资源，导致它们都无法继续执行的情况。

四个必要条件：

- 互斥条件（Mutual Exclusion）：一个资源每次只能被一个进程或线程使用，如果某个资源被一个进程或线程占用，其他进程或线程必须等待释放。
- 持有和等待条件（Hold and Wait）：一个进程或线程可以持有已分配的资源，并在等待获取其他资源时不释放已经占有的资源。
- 不可抢占条件（No Preemption）：系统不可抢占进程或线程占用的资源，只有当进程或线程自愿释放资源时，其他进程或线程才能获取该资源。
- 循环等待条件（Circular Wait）：多个进程或线程之间形成一个循环等待资源的关系。

## 预防死锁

破坏死锁的必要条件：通过破坏死锁的四个必要条件之一，来预防死锁的发生。例如，采用资源预分配、资源抢占、资源超时等方式来避免死锁的发生。

死锁检测与恢复：定期检测系统中是否存在死锁，并采取相应的措施来解除死锁。例如，采用死锁检测算法来检测死锁，并通过资源抢占或进程终止来恢复系统的正常运行。



## 进程调度算法怎么解决死锁

资源预申请：进程在运行前预先申请需要的全部资源，如果资源无法满足，就不允许进程运行，从而避免死锁的发生。

超时机制：设定资源请求的超时时间，如果超过一定时间仍未获得所需资源，则释放已占用的资源并重新请求，以避免因等待资源而导致死锁。

进程终止和回退：如果系统检测到死锁的存在，可以采取终止部分或全部进程的方式来打破死锁，然后重新分配资源。这种策略可能会影响系统的性能和进程的正常运行。

# 多线程下的锁机制

互斥锁是最常见的一种锁，它确保在任何时刻只有一个线程可以获得锁，其他线程必须等待该线程释放锁后才能获取锁。互斥锁适用于对临界区（一段代码或数据，多个线程不能同时访问）的互斥访问。当一个线程获得互斥锁时，其他线程尝试获取该锁会被阻塞，直到持有锁的线程释放锁。

读写锁允许多个线程同时读取共享资源，但是只允许一个线程写入共享资源。当没有线程写入共享资源时，多个线程可以同时读取共享资源，提高了并发性能。当有线程写入共享资源时，其他线程无法读取或写入，直到写入完成。

自旋锁是一种忙等待的锁，当一个线程尝试获取锁时，如果锁已被其他线程持有，则该线程会一直循环检查锁是否可用，直到获取到锁为止。自旋锁适用于锁被持有时间短暂的情况，因为自旋期间会占用 CPU 时间，如果持有锁的时间过长，会浪费 CPU 资源。

# 内存池

预先分配一块连续的内存空间，并将其划分为多个小块（通常是相等大小的块），然后在程序运行过程中重复使用这些小块内存来分配给变量、对象等数据结构。这样可以减少频繁的内存分配和释放操作，提高内存分配的效率，同时也减少了内存碎片化的问题。

# 如果频繁进行内存的分配释放会有什么问题吗？

内存碎片：频繁分配和释放小块内存可能导致内存碎片。碎片化的内存使得找到足够大的连续内存块以满足新的分配请求变得更加困难，从而可能导致分配失败或性能下降。

缓存失效：每次分配和释放内存时，相关的缓存行可能会被无效化，导致CPU需要频繁地从主存中读取数据，降低了缓存的命中率，进而降低了程序的执行效率。

内耗增加：分配和释放内存本身需要消耗CPU时间。频繁的分配和释放意味着CPU将花费更多的时间在内存管理上，而不是在执行实际的计算或业务逻辑。

# 如果频繁分配释放的内存很大（>128k）,怎么处理？

内存池技术：创建一个专门用于分配大块内存的内存池。当需要分配内存时，从内存池中获取，当释放内存时，将其归还给内存池，而不是直接返回给操作系统。这样可以减少内存分配和释放的次数，降低开销，并减少内存碎片。

对象重用：有大量类似的对象需要频繁地创建和销毁，考虑重用对象实例而不是不断地创建新的实例。通过对象池或缓存来存储和管理这些对象，可以显著减少内存分配和释放的次数。

# 分段和分页的区别

**页和段的大小：**

分页：页的大小是固定的，由系统决定，并且系统会将逻辑地址划分为页号和页内地址两部分，这是由机器硬件实现的。在系统中通常只有一种大小的页面。

分段：段的长度不固定，由用户编写的程序决定，通常由编译程序在编译源程序时根据信息的性质来划分。段的起始地址可以是主存的任何位置。

**地址空间：**

分页：地址映射是直接从逻辑地址到物理地址的一步过程。逻辑地址被划分为固定大小的页面，通过页表将逻辑页号映射到物理页号，然后加上页面内偏移得到物理地址。

分段：地址映射是从逻辑地址（由段号和段内偏移组成）到物理地址的两步过程。首先，将逻辑地址中的段号映射到段表中获取段的起始地址，然后加上段内偏移得到物理地址。

# 进程管理

进程创建： 操作系统通过调用fork()或exec()等系统调用来创建新进程。fork()系统调用创建一个与父进程相同的子进程，而exec()系统调用则用于在当前进程的上下文中加载并执行一个新的程序。

进程终止： 进程可以通过调用exit()系统调用来正常终止自己，也可以收到信号等外部事件导致被强制终止。终止的进程会释放其占用的系统资源，如内存、文件描述符等。

进程调度： 进程调度是操作系统根据一定的调度策略从就绪队列中选择下一个要执行的进程的过程。常见的调度策略包括先来先服务、最短作业优先、轮转调度等。

进程状态： 一个进程可以处于就绪状态、运行状态、阻塞状态或终止状态之一。就绪状态表示进程已经准备好运行，但还未获得CPU资源；运行状态表示进程正在执行；阻塞状态表示进程由于某些原因无法继续执行，例如等待I/O操作完成；终止状态表示进程已经结束执行。

进程间通信（IPC）： 进程间通信是指不同进程之间进行数据交换和共享信息的机制。常见的IPC方式包括管道、信号、消息队列、共享内存、套接字等。

进程控制块（PCB）： 操作系统为每个进程维护一个进程控制块，其中包含了进程的各种信息，如进程状态、程序计数器、寄存器内容、进程优先级、进程ID等。操作系统通过操作PCB来管理和控制进程的执行。

# 进程的内存布局以及顺序

栈区：
- 由编译器自动分配释放，速度较快
- 用来存储函数调用时的临时信息的结构，存放为运行时函数分配的局部变量、函数参数、返回数据、返回地址等。这些局部变量等空间都会被释放
- 程序运行过程中函数调用时参数的传递也在栈上进行，如递归调用栈
- 当栈过多的时候，就是导致栈溢出（比如大量的递归调用或者大量的内存分配）
- 栈是向低地址扩展的数据结构，是一块连续的内存的区域，空间有限

堆区：
- 由程序员分配(new,malloc)释放(delete,free)，并指明大小，速度较慢
- 若程序员不释放，导致内存泄漏，new完没有delete，不过在整个程序结束时由操作系统回收,但是这样无疑增加了操作系统的负担
- 高地址扩展的数据结构，是不连续的内存区域，空间很大，比较灵活
- 频繁地分配和释放不同大小的堆空间容易产生内存碎片

当堆区 数据地址 和 栈区数据地址相同时（碰面了） 就代表，数据已用完。

全局区（静态区static）：
- 全局变量和静态变量是放在一起的
- 初始化的全局变量和静态变量（static修饰的）放在一块区域.data节
- 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域.bss（不占磁盘空间，不做具体解释）
- 程序结束后由系统释放

文字常量区：常量字符串就是放在这里，程序结束后由系统释放

程序代码区：存放函数体的二进制代码


# 进程间通信原理和方式

共享内存： 进程可以将某一块内存映射到它们各自的地址空间，实现共享内存的方式进行通信。

消息传递： 可以通过系统调用（如 send 和 receive）或者消息队列来实现消息传递方式的通信。


管道： 进程之间可以通过管道进行通信，一个进程向管道写入数据，另一个进程从管道读取数据。

套接字： 进程可以通过套接字进行网络通信，也可以通过本地套接字进行本地进程间通信。

# 互斥锁+条件变量

互斥锁是一种用于线程间互斥访问共享资源的同步机制。它通过在访问共享资源前加锁，防止其他线程同时访问该资源，从而确保了共享资源的独占性。

条件变量用于线程间的等待和唤醒机制。它通常与互斥锁一起使用，以实现在满足特定条件时线程的等待和唤醒。

```cpp
std::mutex mtx;
std::condition_variable cv;
bool condition = false;

void threadFunction1() {
    std::this_thread::sleep_for(std::chrono::seconds(2)); // 模拟线程1工作时间
    {
        std::lock_guard<std::mutex> lock(mtx);
        condition = true;
    }
    cv.notify_one(); // 唤醒等待的线程
}

void threadFunction2() {
    std::unique_lock<std::mutex> lock(mtx);
    cv.wait(lock, []{ return condition; }); // 等待条件满足
    // 执行线程2的任务
    std::cout << "Thread 2: Condition is satisfied. Continuing execution." << std::endl;
}
```

# 堆和栈的区别

堆是在程序运行时动态分配的内存区域，由程序员手动分配和释放内存。堆的大小不固定，需要显式地调用堆上内存的分配和释放函数。堆上分配的内存可以在程序的任何地方使用，并且其生命周期由程序员控制。

栈是在程序编译时静态分配的内存区域，由系统自动管理。栈的大小在程序编译时就已确定，通常比堆小得多。栈上分配的内存在函数执行完毕时会自动释放，其生命周期与函数调用的生命周期相关。

# fork函数返回值是怎么实现的

fork()函数用于创建一个新的进程，该进程是调用进程（父进程）的副本。fork()函数会创建一个新的进程，并复制父进程的地址空间、文件描述符以及其他资源。

fork()函数的返回值有以下三种情况：

- 父进程中返回子进程的PID： 在父进程中，fork()函数返回新创建的子进程的PID（进程ID），这个PID是一个大于0的整数。
- 子进程中返回0： 在子进程中，fork()函数返回0，表示当前进程是子进程。
- 出错时返回-1： 如果fork()函数调用失败，它会返回-1

调用fork之后，数据、堆、栈有两份，代码仍然为一份但是这个代码段成为两个进程的共享代码段都从fork函数中返回。当父子进程有一个想要修改数据或者堆栈时，两个进程真正分裂。

子进程的代码是从fork处执行的，fork底层实现采用了COW(copy_on_write)技术，写入时拷贝。父进程和子进程共享页帧而不是复制页帧。然而，只要页帧被共享，它们就不能被修改，即页帧被保护。无论父进程还是子进程何时试图写一个共享的页帧，就产生一个异常，这时内核就把这个页复制到一个新的页帧中并标记为可写。原来的页帧仍然是写保护的当其他进程试图写入时，内核检查写进程是否是这个页帧的唯一属主，如果是，就把这个页帧标记为对这个进程是可写的。

# 用户级线程和内核级线程的区别

创建和管理者不同：用户级线程由应用程序创建和管理，而内核级线程由操作系统内核创建和管理。

运行空间与资源访问权限不同：用户级线程运行在用户态，只能访问应用程序的资源。内核级线程运行在内核态，可以访问操作系统的所有资源。

执行服务不同：用户级线程只能执行应用程序提供的服务，而内核级线程可以执行任何操作系统提供的服务，如文件系统、网络等。

调度与切换不同：用户级线程的切换由应用程序自己控制，不需要内核干涉，而内核级线程的切换需要内核控制，由用户态转化为内核态，切换完毕再从内核态返回用户态，比较占用系统资源。

执行系统调用：用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。

# 线程池和线程开销

# 线程切换

## 切换过程

当前线程被阻塞或时间片用完： 当一个线程在执行过程中需要等待某些事件（如等待I/O完成）或者它的时间片用完时，它就会被标记为“就绪状态”或“阻塞状态”。

调度器选择下一个可运行的线程： 在多线程环境下，操作系统的调度器会选择一个处于“就绪状态”的线程来执行。这个选择可以基于不同的调度算法，如轮转调度、优先级调度等。

保存当前线程的上下文： 在进行线程切换之前，操作系统会保存当前线程的上下文信息，包括程序计数器（PC）、寄存器状态等。这是为了在切换回来时能够继续执行该线程。

恢复下一个线程的上下文： 调度器选择了下一个要执行的线程后，会将该线程的上下文信息恢复到 CPU 中，包括程序计数器、寄存器等。

切换完成，新线程开始执行： 当上下文恢复完成后，CPU 开始执行新线程的代码，从上次执行的地方或者是新线程的入口开始执行。

## 开销和影响

上下文切换开销： 线程切换是有开销的，因为操作系统需要保存和恢复线程的上下文信息，这会消耗CPU时间。

竞态条件： 在多线程编程中，线程切换可能会导致一些竞态条件的问题，需要开发人员使用同步机制来解决。

Cache失效： 线程切换可能会导致 CPU Cache 的失效，因为新的线程可能访问不同的内存区域，需要重新加载缓存。

# 线程同步共享怎么实现

互斥锁（Mutex）： 互斥锁是最常见的线程同步机制之一。它可以确保在任意时刻只有一个线程可以访问共享资源。当一个线程尝试获取锁时，如果锁已经被其他线程持有，则该线程会被阻塞，直到锁被释放。常见的互斥锁包括 POSIX 的pthread_mutex_t和 C++11 中的std::mutex。

信号量（Semaphore）： 信号量是一种更为通用的同步机制，它允许多个线程同时访问一定数量的共享资源。信号量维护一个计数器，当计数器大于0时，允许线程访问资源；当计数器等于0时，阻塞线程。信号量通常用于限制资源的并发访问数量。常见的信号量包括 POSIX 的sem_t和C++11中的std::semaphore（C++20标准引入）。

条件变量（Condition Variable）： 条件变量用于在多线程环境下进行线程间的通信和同步。它可以让一个线程等待某个条件为真的通知，并在条件满足时唤醒等待的线程。常见的条件变量包括 POSIX 的pthread_cond_t和C++11中的std::condition_variable。

读写锁（Read-Write Lock）： 读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这种机制适用于读操作远远多于写操作的情况，可以提高并发性能。常见的读写锁包括 POSIX 的pthread_rwlock_t和C++11中的std::shared_mutex。

原子操作（Atomic Operations）： 原子操作是一种无锁的线程同步机制，它提供了一些基本的原子操作，如原子加、原子减、原子赋值等。这些操作能够在不需要锁的情况下实现线程安全的数据访问。C++11标准库提供了一系列原子操作，如std::atomic。

消息队列（Message Queue）： 消息队列是一种线程间通信的方式，它允许线程之间通过发送和接收消息来实现数据共享和同步。每个线程都有自己的消息队列，可以往队列中发送消息，也可以从队列中接收消息。常见的消息队列实现包括 POSIX 的消息队列和ZeroMQ。


# 信号量和自旋锁的区别

信号量： 信号量是一种计数器，用于控制对共享资源的访问。它包括两种操作：wait()和signal()。wait()操作会将信号量的计数器减一，如果计数器为负则阻塞当前线程；signal()操作会将信号量的计数器加一，并唤醒等待的线程。信号量可以用于限制对资源的并发访问数量。

自旋锁： 自旋锁是一种基于忙等待的锁，它使用原子操作在尝试获取锁时不断地进行忙等待，直到成功获取锁为止。自旋锁适用于对共享资源的访问时间很短的情况，避免了线程上下文切换的开销。但是如果锁被持有的时间较长，自旋锁会造成CPU资源的浪费。

信号量通常用于限制对资源的并发访问数量，例如控制线程池中线程的数量，或者控制生产者-消费者模型中生产者和消费者之间的配对。自旋锁适用于对共享资源的访问时间很短的情况，因为它不会引起线程上下文切换的开销。

使用信号量进行线程同步存在线程的阻塞和唤醒操作，这涉及到内核态和用户态之间的切换。自旋锁是基于忙等待的，它避免了线程上下文切换的开销。

# 查看磁盘、cpu 占用、内存占用命令

df：用于查看文件系统的磁盘空间占用情况。
du：用于查看指定目录或文件的磁盘空间占用情况。
top：动态显示系统中各个进程的资源占用情况，包括CPU占用情况
free：用于查看系统内存的使用情况，包括总内存、已使用内存和空闲内存等信息。

# linux虚拟地址空间结构

## 用户空间（User Space）：

代码段（Text Segment）： 也称为代码段或只读段，包含了可执行程序的机器指令。
数据段（Data Segment）： 包含了初始化的全局变量和静态变量。
堆（Heap）： 用于动态分配内存，由malloc()、free()等函数管理。
栈（Stack）： 用于存储局部变量、函数参数、函数返回地址等，由操作系统自动管理。
共享库区域（Shared Libraries）： 包含共享库的代码和数据，被多个进程共享。
内存映射段（Memory Mapped Files）： 用于将文件映射到内存中进行访问，如动态链接库、共享内存等。

## 内核空间（Kernel Space）：

内核代码段（Kernel Code Segment）： 包含操作系统内核的代码。
内核数据段（Kernel Data Segment）： 包含操作系统内核的全局变量和静态变量。
内核堆栈（Kernel Stack）： 用于执行内核模式下的函数调用。
内核堆（Kernel Heap）： 内核使用的动态内存分配区域。

在Linux中，用户空间和内核空间是分开的，每个进程都有自己独立的用户空间，但它们共享同一个内核空间。用户空间和内核空间之间的切换是通过系统调用（System Call）实现的，进程只能通过系统调用来访问内核空间的资源。

# 动态库地址无关代码

动态库的一个主要目的就是允许多个正在运行的进程共享内存中的库代码，以节约内存资源。地址无关代码是指可在主存储器中任意位置正确地运行，而不受其绝对地址影响的一种机器码。PIC广泛使用于共享库，使得同一个库中的代码能够被加载到不同进程的地址空间中。

PIC的基本思想是将指令中那些需要进行重定位的部分剥离出来和数据部分放在一起，这样指令部分就可以保持不变，而数据部分在每个进程中都可以拥有一个副本。

gcc编译时 使用 -fPIC选项

# top命令

## 排查高占有率进程

输入top命令并按回车键执行。通过1来查看每个核的使用情况，找到cpu使用率最高的进程。

使用 top -H -p 进程号 查看异常线程，通过%CPU找到存疑线程。

使用gdb调试，通过thread apply 线程id bt查看该线程的堆栈信息，最后通过走读代码逻辑进行分析。

## 占用率的计算方式

统计程序在用户态和内核态的运行时间除以从启动运行到当前时刻的时间，或者是通过采样某个时间段内任务的运行时间总和算出某个区间内的cpu利用率。

# 查看网络情况

ip addr：用于显示和管理IP地址。

ping命令：用于测试本机与网络中另一台主机之间的连通性。

netstat（网络统计）命令显示网络系统的统计信息，如端口监听、路由表、接口统计、伪装连接、多播成员资格等。

traceroute：是一个网络诊断工具，用于显示数据包从源主机到目的地主机之间经过的路径。

# 操作系统如何分配内存，从哪里分配内存？

请求内存：程序通过系统调用（如malloc或new）请求内存。
虚拟内存分配：操作系统在虚拟地址空间中为程序分配内存。
物理内存映射：当程序访问分配的内存时，如果该内存尚未映射到物理内存，则触发一个“缺页中断”（Page Fault），操作系统随后会从物理内存中分配一个页框（Page Frame），并更新页表来映射虚拟地址到物理地址。

对于用户程序，操作系统通常从虚拟内存中分配内存，根据需要映射到物理内存。这样做可以保护内存，避免不同程序之间的干扰，并允许内存的超额分配。

内核空间的内存通常直接从物理内存分配

# 归还内存时操作系统会做什么？

更新页表：如果内存释放导致了某些内存页不再被任何对象使用，操作系统会更新内部的内存管理数据结构，如页表。

保护内存：将这些内存页标记为受保护的，以防止被错误地访问，直到它们被再次分配给其他进程或线程。

物理内存回收：如果内存释放后，操作系统判断当前的物理内存使用率较低，或者需要为其他更高优先级的任务释放物理内存，会将一些物理内存页归还给系统的空闲内存池。

内存碎片整理：操作系统会尝试合并相邻的空闲内存区域，减少内存碎片，这样可以提高内存的分配效率和最大化可用内存空间。

统计信息更新：操作系统会更新有关内存使用情况的统计信息，包括空闲内存总量、使用量。

