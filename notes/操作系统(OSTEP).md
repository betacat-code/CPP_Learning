# 第一章 虚拟化CPU
## 1.1 进程
进程就是运行中的程序。程序本身只是磁盘上的一些代码和静态数据，是操作系统把其加载到内存中并设置好内存和CPU使得程序可以运行。我们的终极目标是让多个程序并发运行，这就需要虚拟化CPU，机制是分时复用CPU。要实现分时复用CPU，就要实现进程的切换，即上下文切换。另外还需要有调度算法来确定接下来切换到哪一个进程来运行。

程序的指令和静态数据最初都在磁盘上，首先需要将其读入内存中，但现代操作系统惰性（lazily）执行该过程，即仅在程序执行期间需要加载的代码或数据片段，才会加载。

将代码和静态数据加载到内存后，操作系统在运行此进程之前还需要执行其他一些操作。必须为程序的运行时栈（run-time stack 或 stack）分配一些内存。程序使用栈存放局部变量、函数参数和返回地址。操作系统分配这些内存，并提供给进程。

操作系统也可能会用参数初始化栈。具体来说，它会将参数填入 main()函数，即 argc 和 argv数组。

操作系统也可能为程序的堆（heap）分配一些内存。在 C 程序中，堆用于显式请求的动态分配数据。程序通过调用 malloc()来请求这样的空间，并通过调用 free()来明确地释放
它。

## 1.2 机制：受限直接执行

直接执行部分很简单：只需直接在CPU上运行程序即可。因此，当OS希望启动程序运行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码（从磁盘）加载到内存中，找到入口点（main()函数或类似的），跳转到那里，并开始运行用户的代码。
这种方法在我们虚拟化CPU时产生了一些问题。

- 第一个问题：如果我们只运行一个程序，操作系统怎么能确保程序只做我们允许它做的事情，同时仍然高效地运行它？

- 第二个问题：当我们运行一个进程时，操作系统如何让它停下来并切换到另一个进程，从而实现虚拟化CPU所需的时分共享？

### 对于问题1：
引入一种新的处理器模式，称为用户模式（user mode）。在用户模式下运行的代码会受到限制。例如，在用户模式下运行时，进程不能发出I/O请求。这样做会导致处理器引发异常，操作系统可能会终止进程。与用户模式不同的内核模式（kernel mode），操作系统（或内核）就以这种模式运行。在此模式下，运行的代码可以做任何它喜欢的事，包括特权操作，如发出I/O请求和执行所有类型的受限指令。

要执行系统调用，程序必须执行特殊的陷阱（trap）指令,该指令同时跳入内核并将特权级别提升到内核模式。一旦进入内核，系统就可以执行任何需要的特权操作（如果允许），从而为调用进程执行所需的工作。完成后，操作系统调用一个特殊的从陷阱返回（return-from-trap）指令

### 对于问题2：操作系统如何重新获取CPU的控制权？

利用时钟中断重新获得控制权 时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。此时，操作系统重新获得CPU的控制权。

### 保存和恢复上下文
为当前正在执行的进程保存一些寄存器的值（保存到它的内核栈），并为即将执行的进程恢复一些寄存器的值（从它的内核栈取出）。

这样一来，操作系统就可以确保最后执行从陷阱返回指令时，不是返回到之前运行的进程，而是继续执行另一个进程。

## 1.3 进程调度
- 周转时间：一个进程从提交到运行结束的总时间
- 相应时间：一个进程从提交到首次开始运行的时间

### 多级反馈队列：MLFQ

其尝试用历史预测未来。它在运行过程中，根据已经观察到的行为来调整进程的优先级等，从而利用反馈的信息来适应当前情况。
- 设置多个不同优先级的队列，优先运行高优先级队列中的进程。
- 进程提交到系统后，首先放在最高优先级队列中。一个队列中采用轮询调度(Round-Robin)算法来运行。
- 每个队列都有一个时间配额属性，一个进程用完了这个队列规定的时间后就要降到低一级队列。
- 每经过一段时间就要把所有进程重新加入最高级队列。

对于短进程，其可以在较高优先级的队列中较快完成。对于长进程，周期性地把所有进程重新加入最高级队列使其不至于饿死。并且对于不同时间段行为不同的进程，也可以根据其行为来合理地调度它。

MLFQ依然有一些问题，最大的问题是如何配置MLFQ。设置多少队列？每一个队列的RR算法的时间片以及时间配额是多少？提高所有进程优先级的周期是多少？这些问题没有确切答案，可能做就是在运行过程中动态调整来取得平衡。但是让系统自己去学习一个好的参数也不容易，因此我们会有一个包含默认值的配置文件，并且用户可以给出建议从而利于OS动态调整参数。

## 1.4 多处理器调度

多核处理器由于有多个CPU核，而每个CPU都有自己的cache，因此存在一个多核CPU的cache一致性问题。基本解决方法是使用总线，每个CPU都监听其他CPU和内存的操作，如果发现对自己缓存中同一内存地址的数据的更新，就作废cache中的数据（valid设为0）或者直接进行更新。

另外对于多核CPU，并发问题是绕不开的，需要加锁解锁，但高锁争用会导致并行性很差。

cache亲和性：一个进程在一个CPU核上运行时，会在该CPU的cache、TLB、分支预测器等硬件上维护很多状态。如果把一个进程尽量调度到同一个CPU核上，会由于这些缓存中的数据从而运行更快。多处理器调度应该考虑到cache亲和性。

调度策略上，最简单的是复用单核调度：为所有CPU核维护一个队列即可，每个CPU核空闲时都从队列头取出一个进程来运行。其最大优点是简单，但是由于多核并行访问因此需要锁来保证原子性，这就会带来性能损失。还有问题就是cache亲和性，每个CPU核都简单地从队列中取出一个进程来运行，因此每个进程都可能会在不同CPU间迁移，从而不利于cache亲和性。

可以采用多队列调度，为每个CPU维护一个队列。这样锁争用和cache亲和性都不再是问题，但会产生一个问题就是工作负载的分配。例如一个新提交的进程应该加入哪个队列，以及更重要的是如果两个队列的工作负载情况差异较大，应该怎么样实现负载均衡？目前无共识答案。

# 第二章 虚拟化内存